A tree where no leaf is much farther away from the root than any other leaf. Different balancing schemes allow different definitions of “much farther” and different amounts of work to keep them balanced.Consider a height-balancing scheme where following conditions should be checked to determine if a binary tree is balanced.
An empty tree is height-balanced. A non-empty binary tree T is balanced if:
1) Left subtree of T is balanced
2) Right subtree of T is balanced
3) The difference between heights of left subtree and right subtree is not more than 1. The above height-balancing scheme is used in AVL trees. The diagram below shows two trees, one of them is height-balanced and other is not. The second tree is not height-balanced because height of left subtree is 2 more than height of right subtree.To check if a tree is height-balanced, get the height of left and right subtrees. Return true if difference between heights is not more than 1 and left and right subtrees are balanced, otherwise return false.Time Complexity: O(n^2) Worst case occurs in case of skewed tree.
Optimized implementation:  Above implementation can be optimized by calculating the height in the same recursion rather than calling a height() function separately.  Thanks to Amar for suggesting this optimized version. This optimization reduces time complexity to O(n).Time Complexity: O(n)Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.