Consider simple representation (without any dummy node) of Linked List. Functions that operate on such Linked lists can be divided in two categories:1) Functions that do not modify the head pointer:  Examples of such functions include, printing a linked list, updating data members of nodes like adding given a value to all nodes, or some other operation which access/update data of nodes
It is generally easy to decide prototype of functions of this category. We can always pass head pointer as an argument and traverse/update the list. For example, the following function that adds x to data members of all nodes.2) Functions that modify the head pointer:  Examples include, inserting a node at the beginning (head pointer is always modified in this function),  inserting a node at the end (head pointer is modified only when the first node is being inserted),  deleting a given node (head pointer is modified when the deleted node is first node). There may be different ways to update the head pointer in these functions.  Let us discuss these ways using following simple problem:“Given a linked list, write a function deleteFirst() that deletes the first node of a given linked list. For example, if the list is 1->2->3->4, then it should be modified to 2->3->4″Algorithm to solve the problem is a simple 3 step process: (a) Store the head pointer (b) change the head pointer to point to next node (c) delete the previous head node.
Following are different ways to update head pointer in deleteFirst() so that the list is updated everywhere.
2.1) Make head pointer global:  We can make the head pointer global so that it can be accessed and updated in our function.  Following is C code that uses global head pointer.See this for complete running program that uses above function.This is not a recommended way as it has many problems like following:
a) head is globally accessible, so it can be modified anywhere in your project and may lead to unpredictable results.
b) If there are multiple linked lists, then multiple global head pointers with different names are needed.See this to know all reasons why should we avoid global variables in our projects. 
2.2) Return head pointer: We can write deleteFirst() in such a way that it returns the modified head pointer.  Whoever is using this function, have to use the returned value to update the head node.See this for complete program and output.
This approach is much better than the previous 1. There is only one issue with this, if user misses to assign the returned value to head, then things become messy.  C/C++ compilers allows to call a function without assigning the returned value.
2.3) Use Double Pointer: This approach follows the simple C rule: if you want to modify local variable of one function inside another function, pass pointer to that variable. So we can pass pointer to the head pointer to modify the head pointer in our deleteFirst() function.  See this  for complete program and output.
This approach seems to be the best among all three as there are less chances of having problems. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.