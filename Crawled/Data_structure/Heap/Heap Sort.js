Given a Doubly Linked List which has data members sorted in ascending order.  Construct a Balanced Binary Search Tree which has same data members as the given Doubly Linked List. The tree must be constructed in-place (No new node should be allocated for tree conversion) Examples:The Doubly Linked List conversion is very much similar to this Singly Linked List problem and the method 1 is exactly same as the method 1 of previous post.  Method 2 is also almost same. The only difference in method 2 is, instead of allocating new nodes for BST, we reuse same DLL nodes.  We use prev pointer as left and next pointer as right.Method 1 (Simple)
Following is a simple algorithm where we first find the middle node of list and make it root of the tree to be constructed.Time complexity: O(nLogn) where n is the number of nodes in Linked List.Method 2 (Tricky) 
The method 1 constructs the tree from root to leaves.  In this method, we construct from leaves to root. The idea is to insert nodes in BST in the same order as the appear in Doubly Linked List, so that the tree can be constructed in O(n) time complexity.  We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree.  After left subtree is constructed, we assign middle node to root and link the left subtree with root.  Finally, we recursively construct the right subtree and link it with root.
While constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.
Following is C implementation of method 2.  The main code which creates Balanced BST is highlighted. Time Complexity: O(n)Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.