Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time.  
For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.Source: Nearly sorted algorithmWe can use Insertion Sort to sort the elements efficiently. Following is the C code for standard Insertion Sort.The inner loop will run at most k times. To move every element to its correct place, at most k elements need to be moved.  So overall complexity will be O(nk)We can sort such arrays more efficiently with the help of Heap data structure. Following is the detailed process that uses Heap.
1) Create a Min Heap of size k+1 with first k+1 elements. This will take O(k) time (See this GFact)
2) One by one remove min element from heap, put it in result array, and add a new element to heap from remaining elements.Removing an element and adding a new element to min heap will take Logk time. So overall complexity will be O(k) + O((n-k)*logK)Output:
Following is sorted array
2 3 6 8 12 56
The Min Heap based method takes O(nLogk) time and uses O(k) auxiliary space.  We can also use a Balanced Binary Search Tree instead of Heap to store K+1 elements. The insert and delete operations on Balanced BST also take O(Logk) time. So Balanced BST based method will also take O(nLogk) time, but the Heap bassed method seems to be more efficient as the minimum element will always be at root. Also, Heap doesnâ€™t need extra space for left and right pointers.Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.