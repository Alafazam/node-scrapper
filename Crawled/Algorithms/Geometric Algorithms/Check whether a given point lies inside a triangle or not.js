Newspapers and magazines often have crypt-arithmetic puzzles of the form:  
The goal here is to assign each letter a digit from 0 to 9 so that the arithmetic works out correctly. The rules are that all occurrences of a letter must be assigned the same digit, and no digit can be assigned to more than one letter.        make that choice and then recursively try to assign the rest of the characters
        if recursion sucessful, return true
    if !successful, unmake assignment and try another digit 
If all digits have been tried and nothing worked, return false to trigger backtracking 
The algorithm above actually has a lot in common with the permutations algorithm, it pretty much just creates all arrangements of the mapping from characters to digits and tries each until one works or all have been   successfully tried. For a large puzzle, this could take a while.
A smarter algorithm could take into account the structure of the puzzle and avoid going down dead-end paths. For example, if we assign the characters starting from the ones place and moving to the left, at each stage, we can verify the correctness of what we have so far before we continue onwards. This definitely complicates the code but leads to a tremendous improvement in efficiency, making it much more feasible to solve large puzzles. Below pseudocode in this case has more special cases, but the same general design Source:
http://see.stanford.edu/materials/icspacs106b/H19-RecBacktrackExamples.pdfTags: Backtracking