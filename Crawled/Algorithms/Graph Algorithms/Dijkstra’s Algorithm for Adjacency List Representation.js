Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree.  The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. 
For example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process. Depth First Traversal of the following graph is 2, 0, 1, 3See this post for all applications of Depth First Traversal.
Following is C++ implementation of simple Depth First Traversal. The implementation uses adjacency list representation of graphs. STL‘s list container is used to store lists of adjacent nodes.Output:Note that the above code traverses only the vertices reachable from a given source vertex. All the vertices may not be reachable from a given vertex (example Disconnected graph). To do complete DFS traversal of such graphs, we must call DFSUtil() for every vertex. Also, before calling DFSUtil(), we should check if it is already printed by some other call of DFSUtil().  Following implementation does the complete graph traversal even if the nodes are unreachable. The differences from the above code are highlighted in the below code.Time Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Tags: Graph